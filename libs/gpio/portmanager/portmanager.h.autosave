#ifndef PORTMANAGER_H
#define PORTMANAGER_H

///@file
#include <avr/io.h>
#include <stdlib.h>

//#include <serial.h>
#include <math.h>
#include <util/delay.h>
//#include <avr/iomxx0_1.h>
#include <avr/pgmspace.h>
#include <stdio.h>
//#include <stdint.h>
#include "macros.h"

//#define __AVR_ATmega2560__


#define _TIMER0 0x00
#define _TIMER1 0x01
#define _TIMER2 0x02
#define _TIMER3 0x03
#define _TIMER4 0x04
#define _TIMER5 0x05
#define _A	0x00
#define _B	0x01
#define _C	0x02
#define _UART0	0x00
#define _UART1	0x01
#define _UART2	0x02
#define _UART3	0x03
#define isPWM 13
#define OUT_CMP_SEL 10
#define isADC 7
#define LETTER_SEL 8
#define ADC_SEL 3
#define isUART 2
#define UART_SEL 0



#pragma pack(1)
/**
 * @brief The MappedPort struct. It's used to manage pins.
 */
struct MappedPort {
    /**
     * @brief Is the pointer used to manage a pin
     */
    volatile uint8_t * pinx;
    /**
     * @brief The bit into own register
     */
    uint8_t registerBit;

    /*! @var controlBits
        @brief Used to get pin functions mode.
        @verbatim
        ╔═════╦════╦═══════╦══════╦══════╦══════╦══════╦═════╦═══════╦═══╦═══╦═══╦═══╦════════╦═════╦════╗
        ║ 15  ║ 14 ║ 13    ║ 12   ║ 11   ║ 10   ║ 9    ║ 8   ║ 7     ║ 6 ║ 5 ║ 4 ║ 3 ║ 2      ║ 1   ║ 0  ║
        ╠═════╩════╬═══════╬══════╩══════╩══════╬══════╩═════╬═══════╬═══╩═══╩═══╩═══╬════════╬═════╩════╣
        ║ NOT USED ║ isPWM ║ Output Compare Sel ║ Letter Sel ║ isADC ║   ADC_SEL     ║ isUART ║ UART_SEL ║
        ╚══════════╩═══════╩════════════════════╩════════════╩═══════╩═══════════════╩════════╩══════════╝
        @endverbatim
  */
    uint16_t controlBits;

};


#pragma pop
#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
//#include <avr/iom2560.h>
#define _TIMER0 0x00
#define _TIMER1 0x01
#define _TIMER2 0x02
#define _TIMER3 0x03
#define _TIMER4 0x04
#define _TIMER5 0x05
#define _A	0x00
#define _B	0x01
#define _C	0x02
#define _UART0	0x00
#define _UART1	0x01
#define _UART2	0x02
#define _UART3	0x03
#define isPWM 13
#define OUT_CMP_SEL 10
#define isADC 7
#define LETTER_SEL 8
#define ADC_SEL 3
#define isUART 2
#define UART_SEL 0




//#include <avr/iom328p.h>
#elif defined (__AVR_ATmega328P__)
static const PROGMEM MappedPort _flashMappedPort[] ={
    {&PIND,DD0,(0<<isPWM)|(0<<OUT_CMP_SEL)|(0<<LETTER_SEL)|(0<<isADC)|(0<<ADC_SEL)|
     (1<<isUART)|(_UART0<<UART_SEL)},//0	RX - PCINT16

    {&PIND,DD1,(0<<isPWM)|(0<<OUT_CMP_SEL)|(0<<LETTER_SEL)|(0<<isADC)|(0<<ADC_SEL)|
     (1<<isUART)|(_UART0<<UART_SEL)},//1 TX- PCINT17

    {&PIND,DD2,(0<<isPWM)|(0<<OUT_CMP_SEL)|(0<<LETTER_SEL)|(0<<isADC)|(0<<ADC_SEL)|
     (0<<isUART)|(0<<UART_SEL)}, //2 INT0 - PCINT18

    {&PIND,DD3,(1<<isPWM)|(_TIMER2<<OUT_CMP_SEL)|(_B<<LETTER_SEL)|(0<<isADC)|(0<<ADC_SEL)|
     (0<<isUART)|(0<<UART_SEL)}, //3 INT1 - PCINT19

    {&PIND,DD4,(0<<isPWM)|(0<<OUT_CMP_SEL)|(0<<LETTER_SEL)|(0<<isADC)|(0<<ADC_SEL)|
     (0<<isUART)|(0<<UART_SEL)}, //4 T0 - PCINT20 - XCK

    {&PIND,DD5,(1<<isPWM)|(_TIMER0<<OUT_CMP_SEL)|(_B<<LETTER_SEL)|(0<<isADC)|(0<<ADC_SEL)|
     (0<<isUART)|(0<<UART_SEL)}, //5 T1 - PCINT21

    {&PIND,DD6,(1<<isPWM)|(_TIMER0<<OUT_CMP_SEL)|(_A<<LETTER_SEL)|(0<<isADC)|(0<<ADC_SEL)|
     (0<<isUART)|(0<<UART_SEL)}, //6 AIN0 - PCINT22

    {&PIND,DD7,(0<<isPWM)|(0<<OUT_CMP_SEL)|(0<<LETTER_SEL)|(0<<isADC)|(0<<ADC_SEL)|
     (0<<isUART)|(0<<UART_SEL)}, //7 AIN1 - PCINT23

    {&PINB,DD0,(0<<isPWM)|(0<<OUT_CMP_SEL)|(0<<LETTER_SEL)|(0<<isADC)|(0<<ADC_SEL)|
     (0<<isUART)|(0<<UART_SEL)}, //8 CLKO - PCINT0 - ICP1

    {&PINB,DD1,(1<<isPWM)|(_TIMER1<<OUT_CMP_SEL)|(_A<<LETTER_SEL)|(0<<isADC)|(0<<ADC_SEL)|
     (0<<isUART)|(0<<UART_SEL)}, //9 PCINT1

    {&PINB,DD2,(1<<isPWM)|(_TIMER1<<OUT_CMP_SEL)|(_B<<LETTER_SEL)|(0<<isADC)|(0<<ADC_SEL)|
     (0<<isUART)|(0<<UART_SEL)}, //10 PCINT2 - SS

    {&PINB,DD3,(1<<isPWM)|(_TIMER2<<OUT_CMP_SEL)|(_A<<LETTER_SEL)|(0<<isADC)|(0<<ADC_SEL)|
     (0<<isUART)|(0<<UART_SEL)}, //11 PCINT3 - MOSI

    {&PINB,DD4,(0<<isPWM)|(0<<OUT_CMP_SEL)|(0<<LETTER_SEL)|(0<<isADC)|(0<<ADC_SEL)|
     (0<<isUART)|(0<<UART_SEL)}, //12 PCINT4 - MISO

    {&PINB,DD5,(0<<isPWM)|(0<<OUT_CMP_SEL)|(0<<LETTER_SEL)|(0<<isADC)|(0<<ADC_SEL)|
     (0<<isUART)|(0<<UART_SEL)}, //13 PCINT5 - SCK

    {&PINC,DD0,(0<<isPWM)|(0<<OUT_CMP_SEL)|(0<<LETTER_SEL)|(1<<isADC)|(0<<ADC_SEL)|
     (0<<isUART)|(0<<UART_SEL)}, //14 PCINT8

    {&PINC,DD1,(0<<isPWM)|(0<<OUT_CMP_SEL)|(0<<LETTER_SEL)|(1<<isADC)|(1<<ADC_SEL)|
     (0<<isUART)|(0<<UART_SEL)}, //15 PCINT9

    {&PINC,DD2,(0<<isPWM)|(0<<OUT_CMP_SEL)|(0<<LETTER_SEL)|(1<<isADC)|(2<<ADC_SEL)|
     (0<<isUART)|(0<<UART_SEL)}, //16 PCINT10

    {&PINC,DD3,(0<<isPWM)|(0<<OUT_CMP_SEL)|(0<<LETTER_SEL)|(1<<isADC)|(3<<ADC_SEL)|
     (0<<isUART)|(0<<UART_SEL)}, //17 PCINT11

    {&PINC,DD4,(0<<isPWM)|(0<<OUT_CMP_SEL)|(0<<LETTER_SEL)|(1<<isADC)|(4<<ADC_SEL)|
     (0<<isUART)|(0<<UART_SEL)}, //18 PCINT12

    {&PINC,DD5,(0<<isPWM)|(0<<OUT_CMP_SEL)|(0<<LETTER_SEL)|(1<<isADC)|(5<<ADC_SEL)|
     (0<<isUART)|(0<<UART_SEL)}, //19 PCINT13



};
#endif


/**
 * @brief The DDRx enum
 */
enum DDRx:uint8_t{
    INPUT,OUTPUT,INPUT_PULLUP
};

/**
 * @brief The LogicStates enum
 */
enum LogicStates:uint8_t{
    LOW,HIGH
};

/*!
  @brief The Analogx enum
  */
enum Analogx:uint8_t{
    A0=54,
    A1,
    A2,
    A3,
    A4,
    A5,
    A6,
    A7,
    A8,
    A9,
    A10,
    A11,
    A12,
    A13,
    A14,
    A15
};

/**
 * @brief The _ADMUX enum
 */
enum _ADMUX:uint8_t{
    INTERNAL_VREF   = (0<<REFS1) | (0<<REFS0), // AREF,Internal VREF turned OFF
    AVCC            = (0<<REFS1) | (1<<REFS0), // AVCC at AREF Pin with external capacitor
    INTERNAL_1_1V   = (1<<REFS1) | (0<<REFS0), // Internal 1.1Voltage reference with external capacitor at AREF pin
    INTERNAL_2_56V  = (1<<REFS1) | (1<<REFS0), // Internal 2.56Voltage reference with external capacitor at AREF pin
};

/**
 * @brief The _ADCSRA_PRESCALER enum
 */
enum _ADCSRA_PRESCALER:uint8_t{
    F_CPU_BY_2	 = (0<<ADPS2)|(0<<ADPS1)|(1<<ADPS0),
    F_CPU_BY_4	 = (0<<ADPS2)|(1<<ADPS1)|(0<<ADPS0),
    F_CPU_BY_8	 = (0<<ADPS2)|(1<<ADPS1)|(1<<ADPS0),
    F_CPU_BY_16	 = (1<<ADPS2)|(0<<ADPS1)|(0<<ADPS0),
    F_CPU_BY_32	 = (1<<ADPS2)|(0<<ADPS1)|(1<<ADPS0),
    F_CPU_BY_64	 = (1<<ADPS2)|(1<<ADPS1)|(0<<ADPS0),
    F_CPU_BY_128 = (1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0),
};


/**
 * @brief The _ADCSRB_AUTOTRIGGER enum
 */
enum _ADCSRB_AUTOTRIGGER: u8t{
    FREE_RUNNING_MODE         = (0<<ADTS2) | (0<<ADTS1) |(0<<ADTS0),
    ANALOG_COMPARATOR         = (0<<ADTS2) | (0<<ADTS1) |(1<<ADTS0),
    EXTERNAL_INTERRUPT_REQ_0  = (0<<ADTS2) | (1<<ADTS1) |(0<<ADTS0),
    TNCT0_COMP_A              = (0<<ADTS2) | (1<<ADTS1) |(1<<ADTS0),
    TNCT0_OVERFLOW	      = (1<<ADTS2) | (0<<ADTS1) |(0<<ADTS0),
    TNCT1_COMP_B	      = (1<<ADTS2) | (0<<ADTS1) |(1<<ADTS0),
    TNCT1_OVERFLOW	      = (1<<ADTS2) | (1<<ADTS1) |(0<<ADTS0),
    TNCT1_CAPTURE_EVENT	      = (1<<ADTS2) | (1<<ADTS1) |(1<<ADTS0),
};
/**
 * @brief The PWM_8BIT struct
 */
struct PWM_8BIT {
    volatile uint8_t *TCCRxA = (volatile uint8_t *)0xFF;
    volatile uint8_t *TCCRxB = (volatile uint8_t *)0xFF;
    volatile uint8_t *TCNTx  = (volatile uint8_t *)0xFF;
    volatile uint8_t *OCRx   = (volatile uint8_t *)0xFF;
    //volatile uint8_t *OCRxA;
    //volatile uint8_t *OCRxB;
};
/**
 * @brief The PWM_16BIT struct
 */
struct PWM_16BIT : PWM_8BIT {
    volatile uint8_t *TCCRxC = (volatile uint8_t *)0xFF;
    volatile uint8_t *ICRx   = (volatile uint8_t *)0xFF;
};

/**
 * @brief The _LOCAL_CTRL_BITS enum
 */
enum _LOCAL_CTRL_BITS:uint8_t{
    _PWM_8BIT = 0x2, _PWM_16BIT = 0x3, _ADC = 0x4
};
/**
 * @brief The Pin class
 */
class Pin{
public:
    Pin(){}

    /**
     * @brief Pin Constructor
     * @param[in] portNo Is the physical pin of the board
     * @param[in] direction Check DDRx enum
     */
    Pin(uint8_t portNo, DDRx direction);

    ~Pin();

    /**
     * @brief Sets state on of a pin
     */
    void on();

    /**
     * @brief Set state of a pin
     * @param[in] stat  True = on, False = off
     */
    void setState(bool stat = true);

    /**
     * @brief Sets state off of a pin
     */
    void off();

    /**
     * @brief Toggle a pin state
     */
    void toggle();

    /**
     * @brief setDirection
     * @param[in] direction
     */
    void setDirection(DDRx direction);

    /**
     * @brief Set hardware PWM
     * @param[in] freq In hertz
     * @param[in] duty In range 0 - 100
     * @return True if pin has hardware PWM, else  false
     */
    bool setPWM(uint32_t freq, uint8_t duty = 50);

    /**
     * @brief Set duty of hardware PWM
     * @param[in] duty Range 0 - 100
     * @return True if pin has hardware PWM, else  false
     */
    bool setDuty(uint8_t duty);

    /**
     * @brief Set Frequency of hardware PWM
     * @param[in] freq In hertz
     * @return True if pin has hardware PWM, else  false
     */
    bool setFreq(uint16_t freq);

    /**
     * @brief Stop PWM
     * @return True if pin has hardware PWM, else  false
     */
    bool stopPWM();

    /**
     * @brief digitalRead
     * @return True if pin TTL high, else False
     */
    bool digitalRead();

    /**
     * @brief analogRead
     * @param[in] vRef Check _ADMUX enum
     * @param[in] prescaler Check _ADCSRA_PRESCALER enum
     * @param[in] autoTrigger Check _ADCSRB_AUTOTRIGGER enum
     * @return
     */
    uint16_t analogRead(_ADMUX vRef = AVCC, _ADCSRA_PRESCALER prescaler = F_CPU_BY_128, _ADCSRB_AUTOTRIGGER autoTrigger = FREE_RUNNING_MODE);

    /**
     * @brief getPinNumber
     * @return Number of mapped pin into the board
     */
    uint8_t getPinNumber();

    /**
     * @brief Get PWM Duty Cycle
     * @return Percentage of duty cycle. Range : 0% - 100%
     */
    uint8_t getPWM();

    /**
     * @brief Get register bit
     * @return Bits into own register
     */
    uint8_t getRegisterBit();

    /**
     * @brief getPINxAddr
     * @return Mapped address of PINx
     */
    volatile uint8_t *getPINxAddr();

private:
    //---- Methods ----//
    uint16_t calculateTicks(uint32_t freq);

    //---- Variables ----//
    volatile uint8_t *_ddrx;
    volatile uint8_t *_portx;
    volatile uint8_t *_pinx;
    uint16_t channel = 65535;
    uint8_t _registerBit;
    uint8_t _local_ctrl_bits;

    PWM_16BIT _pwm_16BIT;
    PWM_8BIT _pwm_8BIT;

    uint16_t _freq_pwm;
    uint16_t _duty_pwm;
    uint16_t _controlBits;

    uint8_t _pinNumber;
};


#endif // PORTMANAGER_H
